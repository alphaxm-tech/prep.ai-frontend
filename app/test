// "use client";
// import React, {
//   useCallback,
//   useEffect,
//   useMemo,
//   useRef,
//   useState,
// } from "react";

// /**
//  * ChatComposer — a production-ready conversational input for Next.js (App Router)
//  *
//  * Features
//  * - Multiline textarea with auto-resize
//  * - Enter = send, Shift+Enter = newline
//  * - Optional placeholder suggestions
//  * - Character count + maxLength (configurable)
//  * - Disabled / sending state with spinner
//  * - Paste & drop support for small files (base64) — easily adapt to uploads
//  * - Accessible labels and keyboard navigation
//  * - Minimal Tailwind styling (works without Tailwind too)
//  *
//  * Usage (client):
//  *   <ChatComposer onSend={async (payload) => {
//  *     // call your API route
//  *     const res = await fetch("/api/chat", {
//  *       method: "POST",
//  *       headers: { "Content-Type": "application/json" },
//  *       body: JSON.stringify(payload),
//  *     });
//  *     // handle response
//  *   }} />
//  *
//  * Payload shape:
//  *   {
//  *     message: string,
//  *     metadata?: Record<string, any>,
//  *     attachments?: { name: string; type: string; dataUrl: string }[]
//  *   }
//  */

// export type ChatComposerPayload = {
//   message: string;
//   metadata?: Record<string, any>;
//   attachments?: { name: string; type: string; dataUrl: string }[];
// };

// export default function ChatComposer({
//   onSend,
//   placeholder = "Ask anything…",
//   maxLength = 4000,
//   suggestions,
//   autoFocus = true,
// }: {
//   onSend: (payload: ChatComposerPayload) => Promise<void> | void;
//   placeholder?: string;
//   maxLength?: number;
//   suggestions?: string[];
//   autoFocus?: boolean;
// }) {
//   const [value, setValue] = useState("");
//   const [sending, setSending] = useState(false);
//   const [attachments, setAttachments] = useState<
//     ChatComposerPayload["attachments"]
//   >([]);
//   const textareaRef = useRef<HTMLTextAreaElement | null>(null);

//   // Auto-resize textarea height
//   useEffect(() => {
//     const el = textareaRef.current;
//     if (!el) return;
//     el.style.height = "0px";
//     el.style.height = Math.min(el.scrollHeight, 200) + "px"; // cap height
//   }, [value]);

//   const canSend = useMemo(
//     () => value.trim().length > 0 || (attachments && attachments.length > 0),
//     [value, attachments]
//   );

//   const handleSend = useCallback(async () => {
//     if (!canSend || sending) return;
//     setSending(true);
//     try {
//       await onSend({ message: value.trim(), attachments });
//       setValue("");
//       setAttachments([]);
//     } finally {
//       setSending(false);
//     }
//   }, [canSend, sending, onSend, value, attachments]);

//   const onKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
//     if (e.key === "Enter" && !e.shiftKey) {
//       e.preventDefault();
//       handleSend();
//     }
//   };

//   const onPaste = async (e: React.ClipboardEvent<HTMLTextAreaElement>) => {
//     const items = e.clipboardData?.items;
//     if (!items) return;
//     const files: File[] = [];
//     for (const item of items) {
//       if (item.kind === "file") {
//         const f = item.getAsFile();
//         if (f) files.push(f);
//       }
//     }
//     if (files.length) await readAndAttach(files);
//   };

//   const onDrop = async (e: React.DragEvent<HTMLDivElement>) => {
//     e.preventDefault();
//     const files = Array.from(e.dataTransfer.files || []);
//     if (files.length) await readAndAttach(files);
//   };

//   const readAndAttach = async (files: File[]) => {
//     const safe = files.slice(0, 3); // cap number of pasted/dropped files
//     const reads = await Promise.all(
//       safe.map(
//         (file) =>
//           new Promise<{ name: string; type: string; dataUrl: string }>(
//             (resolve, reject) => {
//               const fr = new FileReader();
//               fr.onerror = () => reject(fr.error);
//               fr.onload = () =>
//                 resolve({
//                   name: file.name,
//                   type: file.type,
//                   dataUrl: String(fr.result),
//                 });
//               fr.readAsDataURL(file);
//             }
//           )
//       )
//     );
//     setAttachments((prev) => [...(prev || []), ...reads]);
//   };

//   return (
//     <div
//       className="w-full border rounded-2xl p-3 sm:p-4 shadow-sm bg-white dark:bg-zinc-900"
//       onDrop={onDrop}
//       onDragOver={(e) => e.preventDefault()}
//       aria-label="Chat composer"
//     >
//       {suggestions && suggestions.length > 0 && (
//         <div className="flex flex-wrap gap-2 mb-2">
//           {suggestions.map((s, idx) => (
//             <button
//               key={idx}
//               type="button"
//               className="text-sm px-2 py-1 rounded-full border hover:bg-zinc-50 dark:hover:bg-zinc-800"
//               onClick={() => setValue((v) => (v ? v + " " + s : s))}
//               aria-label={`Insert suggestion: ${s}`}
//             >
//               {s}
//             </button>
//           ))}
//         </div>
//       )}

//       {attachments && attachments.length > 0 && (
//         <div className="flex gap-2 mb-2 flex-wrap" aria-live="polite">
//           {attachments.map((a, i) => (
//             <div
//               key={i}
//               className="flex items-center gap-2 text-xs border rounded-xl px-2 py-1"
//             >
//               <span className="truncate max-w-[10rem]" title={a.name}>
//                 {a.name}
//               </span>
//               <button
//                 className="opacity-70 hover:opacity-100"
//                 onClick={() =>
//                   setAttachments((prev) =>
//                     (prev || []).filter((_, idx) => idx !== i)
//                   )
//                 }
//                 aria-label={`Remove attachment ${a.name}`}
//               >
//                 ✕
//               </button>
//             </div>
//           ))}
//         </div>
//       )}

//       <div className="flex items-end gap-2">
//         <label className="sr-only" htmlFor="chat-input">
//           Message
//         </label>
//         <textarea
//           id="chat-input"
//           ref={textareaRef}
//           value={value}
//           onChange={(e) => setValue(e.target.value.slice(0, maxLength))}
//           onKeyDown={onKeyDown}
//           onPaste={onPaste}
//           placeholder={placeholder}
//           className="flex-1 resize-none outline-none bg-transparent p-2 min-h-[44px] max-h-[200px] leading-relaxed"
//           disabled={sending}
//           autoFocus={autoFocus}
//           aria-disabled={sending}
//           aria-label="Type your message"
//         />
//         <div className="flex items-center gap-2">
//           <input
//             type="file"
//             className="hidden"
//             id="file-input"
//             multiple
//             onChange={async (e) => {
//               const files = Array.from(e.target.files || []);
//               if (files.length) await readAndAttach(files);
//               // reset input so the same file can be selected again
//               e.currentTarget.value = "";
//             }}
//           />
//           <label
//             htmlFor="file-input"
//             className="px-3 py-2 rounded-xl border cursor-pointer text-sm hover:bg-zinc-50 dark:hover:bg-zinc-800"
//             aria-label="Attach files"
//             title="Attach files"
//           >
//             +
//           </label>

//           <button
//             type="button"
//             onClick={handleSend}
//             disabled={!canSend || sending}
//             className="px-4 py-2 rounded-xl bg-black text-white disabled:opacity-50 disabled:cursor-not-allowed"
//             aria-label="Send message"
//           >
//             {sending ? (
//               <span className="inline-flex items-center gap-2">
//                 <Spinner /> Sending
//               </span>
//             ) : (
//               "Send"
//             )}
//           </button>
//         </div>
//       </div>

//       <div className="mt-1 flex items-center justify-between text-xs text-zinc-500">
//         <span>
//           {value.length}/{maxLength}
//         </span>
//         <kbd className="border rounded px-1">Enter</kbd>
//         <span>to send • </span>
//         <kbd className="border rounded px-1">Shift</kbd>
//         <span> + </span>
//         <kbd className="border rounded px-1">Enter</kbd>
//         <span> for newline</span>
//       </div>
//     </div>
//   );
// }

// function Spinner() {
//   return (
//     <svg
//       aria-hidden="true"
//       className="animate-spin h-4 w-4"
//       viewBox="0 0 24 24"
//       fill="none"
//       xmlns="http://www.w3.org/2000/svg"
//     >
//       <circle
//         className="opacity-25"
//         cx="12"
//         cy="12"
//         r="10"
//         stroke="currentColor"
//         strokeWidth="4"
//       ></circle>
//       <path
//         className="opacity-75"
//         fill="currentColor"
//         d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"
//       ></path>
//     </svg>
//   );
// }
